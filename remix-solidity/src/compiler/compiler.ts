'use strict'

var solc = require('solc/wrapper')
var solcABI = require('solc/abi')
var webworkify = require('webworkify')
import compilerInput from './compiler-input'
var remixLib = require('remix-lib')
var EventManager = remixLib.EventManager
import {default as txHelper} from './txHelper';
import { Source, SourceWithTarget, MessageFromWorker, CompilerState, CompilationResult, 
        visitContractsCallbackParam, visitContractsCallbackInterface, CompilationError, gatherImportsCallbackInterface } from './types'

/*
  trigger compilationFinished, compilerLoaded, compilationStarted, compilationDuration
*/
export class Compiler {
  event: any
  state: CompilerState

  constructor (public handleImportCall) {
    this.event = new EventManager()
    this.state = {
      compileJSON: null,
      worker: null,
      currentVersion: null,
      optimize: false,
      evmVersion: null,
      language: 'Solidity',
      compilationStartTime: null,
      target: null,
      lastCompilationResult: {
        data: null,
        source: null
      }
    }

    this.event.register('compilationFinished', (success: boolean, data: CompilationResult, source: SourceWithTarget) => {
      if (success && this.state.compilationStartTime) {
        this.event.trigger('compilationDuration', [(new Date().getTime()) - this.state.compilationStartTime])
      }
      this.state.compilationStartTime = null
    })
  
    this.event.register('compilationStarted', () => {
      this.state.compilationStartTime = new Date().getTime()
    })
  }

  set <K extends keyof CompilerState>(key: K, value: CompilerState[K]) {
    this.state[key] = value
  }

  internalCompile (files: Source, missingInputs?: string[]) {
    this.gatherImports(files, missingInputs, (error, input) => {
      if (error) {
        this.state.lastCompilationResult = null
        this.event.trigger('compilationFinished', [false, {'error': { formattedMessage: error, severity: 'error' }}, files])
      } else {
          if(this.state.compileJSON && input)
            this.state.compileJSON(input)
      }
    })
  }

  compile (files: Source, target: string) {
    this.state.target = target
    this.event.trigger('compilationStarted', [])
    this.internalCompile(files)
  }

  onCompilerLoaded (version: string) {
    this.state.currentVersion = version
    this.event.trigger('compilerLoaded', [version])
  }

  onInternalCompilerLoaded () {
    if (this.state.worker === null) {
      const compiler: any = typeof (window) === 'undefined' ? require('solc') : solc(window['Module'])
      this.state.compileJSON = (source: SourceWithTarget) => {
        let missingInputs: string[] = []
        let missingInputsCallback = (path: string) => {
          missingInputs.push(path)
          return { error: 'Deferred import' }
        }

        let result: CompilationResult = {}
        try {
          if(source && source.sources) {
            let input = compilerInput(source.sources, {optimize: this.state.optimize, evmVersion: this.state.evmVersion, language: this.state.language})
            result = JSON.parse(compiler.compile(input, { import: missingInputsCallback }))
          }
        } catch (exception) {
          result = { error: { formattedMessage: 'Uncaught JavaScript exception:\n' + exception, severity: 'error', mode: 'panic' } }
        }
        this.compilationFinished(result, missingInputs, source)
      }
      this.onCompilerLoaded(compiler.version())
    }
  }

  compilationFinished (data: CompilationResult, missingInputs?: string[], source?: SourceWithTarget) {
    let noFatalErrors: boolean = true // ie warnings are ok

    let isValidError = (error: CompilationError) => {
      // The deferred import is not a real error
      // FIXME: maybe have a better check?
      if (error.message && /Deferred import/.exec(error.message)) {
        return false
      }

      return error.severity !== 'warning'
    }

    if (data['error'] !== undefined) {
      // Ignore warnings (and the 'Deferred import' error as those are generated by us as a workaround
      if (isValidError(data['error'])) {
        noFatalErrors = false
      }
    }
    if (data['errors'] !== undefined) {
      data['errors'].forEach((err) => {
        // Ignore warnings and the 'Deferred import' error as those are generated by us as a workaround
        if (isValidError(err)) {
          noFatalErrors = false
        }
      })
    }

    if (!noFatalErrors) {
      // There are fatal errors - abort here
      this.state.lastCompilationResult = null
      this.event.trigger('compilationFinished', [false, data, source])
    } else if (missingInputs && missingInputs.length > 0 && source && source.sources) {
      // try compiling again with the new set of inputs

      this.internalCompile(source.sources, missingInputs)
    } else {
      data = this.updateInterface(data)
      if(source)
      {
        this.state.lastCompilationResult = {
          data: data,
          source: source
        }
        source.target = this.state.target;
      }
      this.event.trigger('compilationFinished', [true, data, source])
    }
  }

  // TODO: needs to be changed to be more node friendly
  loadVersion (usingWorker: boolean, url: string) {
    console.log('Loading ' + url + ' ' + (usingWorker ? 'with worker' : 'without worker'))
    this.event.trigger('loadingCompiler', [url, usingWorker])

    if (this.state.worker !== null) {
      this.state.worker.terminate()
      this.state.worker = null
    }
    if (usingWorker) {
      this.loadWorker(url)
    } else {
      this.loadInternal(url)
    }
  }

  loadInternal (url: string) {
    delete window['Module']
    // NOTE: workaround some browsers?
    window['Module'] = undefined

    // Set a safe fallback until the new one is loaded
    this.set('compileJSON', (source: SourceWithTarget) => {
      this.compilationFinished({ error: { formattedMessage: 'Compiler not yet loaded.' } })
    })

    let newScript: any = document.createElement('script')
    newScript.type = 'text/javascript'
    newScript.src = url
    document.getElementsByTagName('head')[0].appendChild(newScript)
    let check: any = window.setInterval(() => {
      if (!window['Module']) {
        return
      }
      window.clearInterval(check)
      this.onInternalCompilerLoaded()
    }, 200)
  }

  loadWorker (url: string) {
    this.state.worker = webworkify(require('./compiler-worker.js').default)
    let jobs: Record<'sources', SourceWithTarget> [] = []
    this.state.worker.addEventListener('message', (msg: Record <'data', MessageFromWorker>) => {
      const data: MessageFromWorker = msg.data
      switch (data.cmd) {
        case 'versionLoaded':
          if(data.data)
            this.onCompilerLoaded(data.data)
          break
        case 'compiled':
          let result: CompilationResult 
          if(data.data && data.job) {
            try {
              result = JSON.parse(data.data)
            } catch (exception) {
              result = { error : { formattedMessage: 'Invalid JSON output from the compiler: ' + exception }}
            }
            let sources: SourceWithTarget = {}
            if (data.job in jobs !== undefined && jobs[data.job].sources) {
              sources = jobs[data.job].sources
              delete jobs[data.job]
            }
            this.compilationFinished(result, data.missingInputs, sources)
          }
          break
      }
    })
    this.state.worker.addEventListener('error', (msg: Record <'data', MessageFromWorker>) => {
      this.compilationFinished({ error: { formattedMessage: 'Worker error: ' + msg.data }})
    })
    this.state.compileJSON = (source: SourceWithTarget) => {
      if(source && source.sources) {
        jobs.push({sources: source})
        this.state.worker.postMessage({cmd: 'compile', job: jobs.length - 1, input: compilerInput(source.sources,
        {optimize: this.state.optimize, evmVersion: this.state.evmVersion, language: this.state.language})})
      }
    }
    this.state.worker.postMessage({cmd: 'loadVersion', data: url})
  }

  gatherImports (files: Source, importHints?: string[], cb?: gatherImportsCallbackInterface) {
    importHints = importHints || []

    // FIXME: This will only match imports if the file begins with one.
    //        It should tokenize by lines and check each.
    // eslint-disable-next-line no-useless-escape
    const importRegex: RegExp = /^\s*import\s*[\'\"]([^\'\"]+)[\'\"];/g

    for (const fileName in files) {
      let match: RegExpExecArray | null
      while ((match = importRegex.exec(files[fileName].content))) {
        let importFilePath = match[1]
        if (importFilePath.startsWith('./')) {
          const path: RegExpExecArray | null = /(.*\/).*/.exec(fileName)
          if (path !== null) {
            importFilePath = importFilePath.replace('./', path[1])
          } else {
            importFilePath = importFilePath.slice(2)
          }
        }

        // FIXME: should be using includes or sets, but there's also browser compatibility..
        if (importHints.indexOf(importFilePath) === -1) {
          importHints.push(importFilePath)
        }
      }
    }

    while (importHints.length > 0) {
      const m: string | undefined = importHints.pop()
      if (m && m in files) {
        continue
      }

      if (this.handleImportCall) {
        this.handleImportCall(m, (err, content) => {
          if (err && cb) {
            cb(err)
          } else {
              if(m){
                files[m] = { content }
                this.gatherImports(files, importHints, cb)
              }
          }
        })
      }

      return
    }
    if(cb)
      cb(null, { 'sources': files })
  }

  truncateVersion (version: string): string {
    const tmp: RegExpExecArray | null = /^(\d+.\d+.\d+)/.exec(version)
    if (tmp) {
      return tmp[1]
    }
    return version
  }
  
  updateInterface (data: CompilationResult) : CompilationResult {
    txHelper.visitContracts(data.contracts, (contract : visitContractsCallbackParam) => {
      if (!contract.object.abi) contract.object.abi = []
      if (this.state.language === 'Yul' && contract.object.abi.length === 0) {
        // yul compiler does not return any abi,
        // we default to accept the fallback function (which expect raw data as argument).
        contract.object.abi.push({
          'payable': true,
          'stateMutability': 'payable',
          'type': 'fallback'
        })
      }
      if(data && data.contracts && this.state.currentVersion)
        data.contracts[contract.file][contract.name].abi = solcABI.update(this.truncateVersion(this.state.currentVersion), contract.object.abi)
    })
    return data
  }

  /**
    * return the contract obj of the given @arg name. Uses last compilation result.
    * return null if not found
    * @param {String} name    - contract name
    * @returns contract obj and associated file: { contract, file } or null
    */
   getContract (name: string): Record<string, any> | null {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return txHelper.getContract(name, this.state.lastCompilationResult.data.contracts)
    }
    return null
  }

  /**
    * call the given @arg cb (function) for all the contracts. Uses last compilation result
    * @param cb    - callback
    */
  visitContracts (cb: visitContractsCallbackInterface) : void | null {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return txHelper.visitContracts(this.state.lastCompilationResult.data.contracts, cb)
    }
    return null
  }

  /**
    * return the compiled contracts from the last compilation result
    */
  getContracts () : CompilationResult['contracts'] | null {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return this.state.lastCompilationResult.data.contracts
    }
    return null
  }

   /**
    * return the sources from the last compilation result
    */
  getSources () : Source | null | undefined {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.source) {
      return this.state.lastCompilationResult.source.sources
    }
    return null
  }

  /**
    * return the sources @arg fileName from the last compilation result
    * @param {Object} cb    - map of sources
    */
  getSource (fileName: string) : Source['filename'] | null {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.source && this.state.lastCompilationResult.source.sources) {
      return this.state.lastCompilationResult.source.sources[fileName]
    }
    return null
  }

  /**
    * return the source from the last compilation result that has the given index. null if source not found
    * @param index    - index of the source
    */
  getSourceName (index: number): string | null {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.sources) {
      return Object.keys(this.state.lastCompilationResult.data.sources)[index]
    }
    return null
  }
}

